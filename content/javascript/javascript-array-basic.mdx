---
title: 'JavaScript 배열 필수 메서드 완벽 가이드'
description: 'map, filter, reduce, splice의 개념부터 실전 활용까지'
date: '2025-10-12'
---

# JavaScript 배열 필수 메서드 완벽 가이드

현대 JavaScript 개발에서 배열은 가장 많이 사용되는 데이터 구조 중 하나입니다. 특히 `map`, `filter`, `reduce`, `splice`와 같은 메서드들은 배열을 효과적으로 다루기 위한 필수 도구입니다. 이 글에서는 각 메서드의 기본 개념부터 실전 활용까지 자세히 알아보겠습니다.

<Callout type='info' title='학습 목표'>
  이 글을 통해 다음과 같은 내용을 배울 수 있습니다:
  - 각 메서드의 기본 개념과 사용법
  - 불변성(Immutability)의 개념과 중요성
  - 실제 프로젝트에서의 활용 사례
  - 메서드 간의 차이점과 선택 기준
</Callout>

## 1. map - 변환의 마법사

`map` 메서드는 배열의 각 요소를 변환하여 새로운 배열을 생성합니다. 원본 배열은 변경되지 않으며, 항상 같은 길이의 새로운 배열을 반환합니다.

### 기본 구문

```javascript
const newArray = array.map((element, index, array) => {
  // 변환 로직
  return transformedElement;
});
```

### 실전 예제

```javascript
// 기본적인 값 변환
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 객체 배열 변환
const users = [
  { id: 1, name: '김철수', age: 25 },
  { id: 2, name: '이영희', age: 30 },
  { id: 3, name: '박민수', age: 28 },
];

const userNames = users.map((user) => user.name);
console.log(userNames); // ['김철수', '이영희', '박민수']

// 인덱스 활용
const indexedNames = users.map((user, index) => `${index + 1}. ${user.name}`);
console.log(indexedNames); // ['1. 김철수', '2. 이영희', '3. 박민수']
```

### 실제 활용 사례

```javascript
// API 응답 데이터 변환
const apiResponse = [
  { id: 1, first_name: 'John', last_name: 'Doe' },
  { id: 2, first_name: 'Jane', last_name: 'Smith' },
];

const formattedUsers = apiResponse.map((user) => ({
  id: user.id,
  fullName: `${user.first_name} ${user.last_name}`,
  displayName: `${user.last_name}, ${user.first_name}`,
}));

// React 컴포넌트 렌더링
const UserList = ({ users }) => (
  <ul>
    {users.map((user) => (
      <li key={user.id}>
        {user.name} ({user.age}세)
      </li>
    ))}
  </ul>
);
```

<Callout type='note' title='💡 기억할 점'>
  `map`은 항상 새로운 배열을 반환하며, 원본 배열을 수정하지 않습니다. 각 요소에
  대한 변환 로직을 적용할 때 사용하세요.
</Callout>

<Callout type='info' title='🔄 for 반복문의 현대적인 대안'>
  `map`은 **새로운 배열을 생성하는 것이 주 목적**이지만, 콜백 함수를 호출할 수 있다는 점 때문에
  전통적인 `for` 반복문을 대체하는 용도로도 많이 사용됩니다.

  ```javascript
  // ❌ 전통적인 for 반복문
  const numbers = [1, 2, 3, 4, 5];
  for (let i = 0; i < numbers.length; i++) {
    console.log(`인덱스 ${i}: ${numbers[i]}`);
  }

  // ✅ map을 활용한 함수형 접근
  numbers.map((num, index) => {
    console.log(`인덱스 ${index}: ${num}`);
    return num; // 변환 로직이 필요 없어도 return 필요
  });

  // 더 깔끔한 방법: forEach 사용 (단순 반복만 필요한 경우)
  numbers.forEach((num, index) => {
    console.log(`인덱스 ${index}: ${num}`);
  });
  ```

  **언제 map을 사용할까?**
  - **새로운 배열이 필요할 때**: `map` 사용
  - **단순 반복만 필요할 때**: `forEach` 사용 (가독성 향상)
  - **부수 효과만 필요한 경우**: `forEach`가 더 적절

  ```javascript
  // 변환 + 반복의 결합
  const processedData = rawData
    .map(item => transformItem(item))  // 변환
    .map((item, index) => {
      logProcessing(index, item);     // 부수 효과
      return item;
    });
  ```
</Callout>

## 2. filter - 조건에 맞는 요소만 골라내기

`filter` 메서드는 주어진 조건 함수를 통과하는 요소만을 모아 새로운 배열을 생성합니다. 원본 배열은 변경되지 않습니다.

### 기본 구문

```javascript
const filteredArray = array.filter((element, index, array) => {
  // 조건 로직 (true를 반환하면 요소가 포함됨)
  return condition;
});
```

### 실전 예제

```javascript
// 숫자 필터링
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]

const oddNumbers = numbers.filter((num) => num % 2 !== 0);
console.log(oddNumbers); // [1, 3, 5, 7, 9]

// 객체 배열 필터링
const products = [
  { id: 1, name: '노트북', price: 1000000, category: '전자제품' },
  { id: 2, name: '책상', price: 150000, category: '가구' },
  { id: 3, name: '키보드', price: 50000, category: '전자제품' },
  { id: 4, name: '의자', price: 200000, category: '가구' },
];

const electronics = products.filter(
  (product) => product.category === '전자제품'
);

const affordable = products.filter((product) => product.price <= 200000);

console.log(electronics); // 노트북, 키보드
console.log(affordable); // 책상, 키보드, 의자
```

### 실제 활용 사례

```javascript
// 검색 기능 구현
const searchProducts = (products, query) => {
  return products.filter((product) =>
    product.name.toLowerCase().includes(query.toLowerCase())
  );
};

// 유효성 검증
const validUsers = users.filter(
  (user) => user.email && user.email.includes('@') && user.age >= 18
);

// 중복 제거 (map과 조합)
const uniqueCategories = [
  ...new Set(products.map((product) => product.category)),
];
```

<Callout type='warning' title='⚠️ 주의사항'>
  `filter`는 조건 함수가 `true`를 반환하는 요소만 포함합니다. `false`, `null`,
  `undefined`, `0`, `NaN`, `''`는 모두 false로 간주됩니다.
</Callout>

<Callout type='info' title='🔍 실무에서의 주요 사용 사례'>
  `filter`는 **조건에 맞는 요소만 추출하는 것이 주 목적**이지만, 실제로는 다음과 같은 다양한 시나리오에서 핵심적인 역할을 합니다:

  ```javascript
  // 🔍 검색 및 필터링 UI
  const handleSearch = (query) => {
    const filtered = products.filter(product =>
      product.name.toLowerCase().includes(query.toLowerCase()) ||
      product.category.toLowerCase().includes(query.toLowerCase())
    );
    setFilteredProducts(filtered);
  };

  // ✅ 데이터 유효성 검증
  const validateUsers = (users) => {
    const valid = users.filter(user =>
      user.email?.includes('@') &&
      user.age >= 18 &&
      user.name?.trim().length > 0
    );
    const invalid = users.filter(user => !valid.includes(user));
    return { valid, invalid };
  };

  // 🗂️ 데이터 분류 및 정리
  const categorizeProducts = (products) => ({
    expensive: products.filter(p => p.price > 100000),
    affordable: products.filter(p => p.price <= 100000),
    discontinued: products.filter(p => p.status === 'discontinued')
  });

  // 🔄 실시간 데이터 필터링 (React 등에서)
  const visibleTodos = todos.filter(todo =>
    filter === 'all' ? true :
    filter === 'active' ? !todo.completed :
    filter === 'completed' ? todo.completed : true
  );
  ```
</Callout>

## 3. reduce - 배열을 하나의 값으로 축소하기

`reduce` 메서드는 배열의 모든 요소를 하나의 값으로 축소합니다. 누적 계산, 그룹화, 변환 등 다양한 용도로 사용할 수 있습니다.

### 기본 구문

```javascript
const result = array.reduce((accumulator, currentValue, index, array) => {
  // 축소 로직
  return newAccumulator;
}, initialValue);
```

### 실전 예제

```javascript
// 합계 계산
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15

// 최대값 찾기
const max = numbers.reduce((acc, num) => Math.max(acc, num), -Infinity);
console.log(max); // 5

// 객체로 그룹화
const fruits = [
  { name: '사과', category: '과일' },
  { name: '바나나', category: '과일' },
  { name: '당근', category: '채소' },
  { name: '토마토', category: '채소' },
];

const groupedByCategory = fruits.reduce((acc, fruit) => {
  if (!acc[fruit.category]) {
    acc[fruit.category] = [];
  }
  acc[fruit.category].push(fruit.name);
  return acc;
}, {});

console.log(groupedByCategory);
// { 과일: ['사과', '바나나'], 채소: ['당근', '토마토'] }
```

### 실제 활용 사례

```javascript
// 장바구니 총액 계산
const cart = [
  { name: '노트북', price: 1000000, quantity: 1 },
  { name: '마우스', price: 50000, quantity: 2 },
  { name: '키보드', price: 80000, quantity: 1 },
];

const totalPrice = cart.reduce(
  (total, item) => total + item.price * item.quantity,
  0
);

// 데이터 분석
const userStats = users.reduce(
  (stats, user) => {
    stats.totalAge += user.age;
    stats.count += 1;
    stats.averageAge = stats.totalAge / stats.count;
    return stats;
  },
  { totalAge: 0, count: 0, averageAge: 0 }
);

// 배열 평탄화
const nestedArrays = [
  [1, 2],
  [3, 4],
  [5, 6],
];
const flatArray = nestedArrays.reduce((acc, arr) => acc.concat(arr), []);
```

<Callout type='success' title='🚀 고급 활용'>
  `reduce`는 `map`, `filter`의 기능을 모두 구현할 수 있을 만큼 강력합니다.
  하지만 가독성을 위해 적절한 메서드를 선택하세요.
</Callout>

<Callout type='info' title='📊 실무에서의 다양한 활용 패턴'>
  `reduce`는 **배열을 하나의 값으로 축소하는 것이 주 목적**이지만, 그 유연성 때문에 실제로는 다음과 같은 다양한 시나리오에서 핵심적인 역할을 합니다:

  ```javascript
  // 📈 통계 및 분석
  const analyzeSales = (orders) => orders.reduce((stats, order) => {
    stats.totalRevenue += order.amount;
    stats.orderCount += 1;
    stats.averageOrder = stats.totalRevenue / stats.orderCount;
    return stats;
  }, { totalRevenue: 0, orderCount: 0, averageOrder: 0 });

  // 🏷️ 데이터 그룹화 및 분류
  const groupByCategory = (products) => products.reduce((groups, product) => {
    const category = product.category;
    if (!groups[category]) groups[category] = [];
    groups[category].push(product);
    return groups;
  }, {});

  // 🔄 복잡한 데이터 변환
  const transformData = (rawData) => rawData.reduce((result, item, index) => {
    result.processed.push({
      id: item.id,
      name: item.name.toUpperCase(),
      index: index + 1,
      isFirst: index === 0,
      isLast: index === rawData.length - 1
    });
    result.metadata.totalItems = index + 1;
    return result;
  }, { processed: [], metadata: { totalItems: 0 } });

  // 🧮 비동기 작업 체이닝
  const processAsync = async (items) => {
    return items.reduce(async (promise, item) => {
      const result = await promise;
      const processedItem = await processItemAsync(item);
      result.push(processedItem);
      return result;
    }, Promise.resolve([]));
  };

  // 📝 객체 생성 및 변환
  const arrayToObject = (array, keySelector) => array.reduce((obj, item) => {
    obj[keySelector(item)] = item;
    return obj;
  }, {});
  ```
</Callout>

## 4. splice - 배열 직접 수정하기

`splice` 메서드는 배열의 요소를 추가, 삭제, 교체할 수 있습니다. **원본 배열을 직접 수정**한다는 점이 다른 메서드들과 다릅니다.

### 기본 구문

```javascript
// 요소 삭제
array.splice(startIndex, deleteCount);

// 요소 추가
array.splice(startIndex, 0, ...itemsToAdd);

// 요소 교체
array.splice(startIndex, deleteCount, ...itemsToAdd);
```

### 실전 예제

```javascript
let fruits = ['사과', '바나나', '오렌지', '포도', '키위'];

// 요소 삭제
const removed = fruits.splice(2, 1); // 인덱스 2부터 1개 삭제
console.log(fruits); // ['사과', '바나나', '포도', '키위']
console.log(removed); // ['오렌지']

// 요소 추가
fruits.splice(2, 0, '체리', '블루베리'); // 인덱스 2에 추가
console.log(fruits); // ['사과', '바나나', '체리', '블루베리', '포도', '키위']

// 요소 교체
fruits.splice(1, 2, '망고', '파인애플'); // 인덱스 1부터 2개를 교체
console.log(fruits); // ['사과', '망고', '파인애플', '블루베리', '포도', '키위']
```

### 실제 활용 사례

```javascript
// 할 일 목록 관리
class TodoList {
  constructor() {
    this.todos = [];
  }

  addTodo(todo, index = this.todos.length) {
    this.todos.splice(index, 0, todo);
  }

  removeTodo(index) {
    return this.todos.splice(index, 1)[0];
  }

  updateTodo(index, newTodo) {
    this.todos.splice(index, 1, newTodo);
  }
}

// 큐 구현
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(item) {
    this.items.splice(this.items.length, 0, item);
  }

  dequeue() {
    return this.items.splice(0, 1)[0];
  }
}
```

<Callout type='error' title='❌ 위험성'>
  `splice`는 원본 배열을 직접 수정하므로, 불변성을 유지해야 하는 경우 주의해서
  사용하세요. 가능하다면 `slice`, `concat` 등을 고려해보세요.
</Callout>

<Callout type='info' title='⚙️ 실무에서의 핵심 활용 사례'>
  `splice`는 **배열을 직접 수정하는 것이 주 목적**이지만, 그 유연성 때문에 실제로는 다음과 같은 다양한 데이터 구조와 알고리즘 구현에 필수적입니다:

  ```javascript
  // 📋 할 일 관리 애플리케이션
  class TodoManager {
    constructor() {
      this.todos = [];
    }

    addTodoAt(todo, index) {
      this.todos.splice(index, 0, { ...todo, id: Date.now() });
    }

    moveTodo(fromIndex, toIndex) {
      const [todo] = this.todos.splice(fromIndex, 1);
      this.todos.splice(toIndex, 0, todo);
    }

    replaceRange(startIndex, deleteCount, newTodos) {
      this.todos.splice(startIndex, deleteCount, ...newTodos);
    }
  }

  // 🎯 게임 개발에서의 배열 관리
  class GameBoard {
    constructor(size) {
      this.board = Array(size * size).fill(null);
    }

    placePiece(position, piece) {
      this.board.splice(position, 1, piece);
    }

    removePiece(position) {
      this.board.splice(position, 1, null);
    }

    insertRow(rowIndex, newRow) {
      const startIndex = rowIndex * this.size;
      this.board.splice(startIndex, this.size, ...newRow);
    }
  }

  // 🔄 실시간 데이터 동기화
  class LiveDataManager {
    constructor() {
      this.data = [];
    }

    // 서버에서 받은 변경사항 적용
    applyChanges(changes) {
      changes.forEach(change => {
        switch(change.type) {
          case 'insert':
            this.data.splice(change.index, 0, change.item);
            break;
          case 'update':
            this.data.splice(change.index, 1, change.item);
            break;
          case 'delete':
            this.data.splice(change.index, 1);
            break;
        }
      });
    }
  }

  // 📊 정렬 알고리즘 구현
  function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
      const current = arr[i];
      let j = i - 1;

      while (j >= 0 && arr[j] > current) {
        arr.splice(j + 1, 1, arr[j]); // 요소 이동
        j--;
      }
      arr.splice(j + 1, 1, current);
    }
    return arr;
  }
  ```
</Callout>

## 메서드 비교 및 선택 가이드

<Tabs defaultValue='comparison'>
  <TabsList>
    <TabsTrigger value='comparison'>특성 비교</TabsTrigger>
    <TabsTrigger value='usage'>사용 사례</TabsTrigger>
    <TabsTrigger value='immutability'>불변성</TabsTrigger>
    <TabsTrigger value='performance'>성능 고려사항</TabsTrigger>
  </TabsList>

  <TabsContent value='comparison'>
    | 메서드 | 반환값 | 원본 수정 | 용도 |
    |--------|--------|-----------|------|
    | `map` | 새로운 배열 | ❌ | 요소 변환 |
    | `filter` | 새로운 배열 | ❌ | 요소 필터링 |
    | `reduce` | 단일 값 | ❌ | 축소/집계 |
    | `splice` | 삭제된 요소 배열 | ✅ | 직접 수정 |

  </TabsContent>

  <TabsContent value='usage'>
    ### 언제 어떤 메서드를 사용할까?

    - **map**: 모든 요소를 변환할 때, 반복문을 대체할 때
    - **filter**: 검색/필터링, 유효성 검증, 데이터 분류할 때
    - **reduce**: 통계 계산, 그룹화, 복잡한 변환, 객체 생성할 때
    - **splice**: 데이터 구조 구현, 실시간 수정, 알고리즘 구현할 때 (주의해서 사용)

    ```javascript
    // 같은 결과를 내는 다른 방법들
    const numbers = [1, 2, 3, 4, 5];

    // map + filter 조합
    const result1 = numbers
      .filter(num => num % 2 === 0)
      .map(num => num * 2);

    // reduce로 동일한 결과
    const result2 = numbers.reduce((acc, num) => {
      if (num % 2 === 0) {
        acc.push(num * 2);
      }
      return acc;
    }, []);
    ```

  </TabsContent>

  <TabsContent value='immutability'>
    ### 불변성(Immutability)이란?

    **불변성**은 데이터가 생성된 후에는 그 상태를 변경할 수 없도록 하는 프로그래밍 원칙입니다. JavaScript에서 배열의 불변성은 원본 배열을 수정하지 않고 새로운 배열을 생성하는 것을 의미합니다.

    #### 왜 불변성이 중요한가?

    1. **예측 가능한 코드**: 데이터가 변경되지 않으므로 디버깅이 쉽습니다
    2. **React와 같은 라이브러리**: 상태 변경 감지에 불변성이 필요합니다
    3. **함수형 프로그래밍**: 부수 효과(side effects)를 방지합니다
    4. **시간 여행 디버깅**: 이전 상태로 쉽게 돌아갈 수 있습니다
    5. **병렬 처리**: 공유 상태가 없어 안전하게 병렬 처리할 수 있습니다

    #### 각 메서드의 불변성 여부

    | 메서드 | 불변성 유지 | 원본 배열 변경 |
    |--------|-------------|----------------|
    | `map` | ✅ | ❌ (새로운 배열 반환) |
    | `filter` | ✅ | ❌ (새로운 배열 반환) |
    | `reduce` | ✅ | ❌ (축소된 값 반환) |
    | `splice` | ❌ | ✅ (원본 배열 직접 수정) |

    ```javascript
    const original = [1, 2, 3, 4, 5];

    // 불변성 유지 (새로운 배열 생성)
    const mapped = original.map(x => x * 2); // [2, 4, 6, 8, 10]
    console.log(original); // [1, 2, 3, 4, 5] - 변경되지 않음

    // 불변성 깨짐 (원본 배열 수정)
    const spliced = original.splice(2, 2); // [3, 4] 반환
    console.log(original); // [1, 2, 5] - 변경됨!
    ```

    #### 불변성을 깨는 메서드들

    다음 메서드들은 원본 배열을 직접 수정합니다:

    ```javascript
    const arr = [1, 2, 3, 4, 5];

    // ❌ 원본 수정
    arr.push(6);        // 끝에 추가
    arr.pop();          // 끝에서 제거
    arr.shift();        // 앞에서 제거
    arr.unshift(0);     // 앞에 추가
    arr.splice(2, 1);   // 지정 위치에서 제거/추가
    arr.sort();         // 정렬
    arr.reverse();      // 역순 정렬
    ```

    #### 불변성을 유지하는 대안 방법

    ```javascript
    const arr = [1, 2, 3, 4, 5];

    // ✅ 불변성 유지
    const added = [...arr, 6];                    // push 대체
    const removed = arr.slice(0, -1);             // pop 대체
    const shifted = arr.slice(1);                 // shift 대체
    const unshifted = [0, ...arr];                // unshift 대체
    const spliced = [...arr.slice(0, 2), ...arr.slice(3)]; // splice 대체
    const sorted = [...arr].sort();               // sort 대체
    const reversed = [...arr].reverse();          // reverse 대체
    ```

    #### React에서의 불변성 중요성

    ```javascript
    // ❌ 잘못된 예: 직접 상태 수정
    const handleAddItem = () => {
      items.push(newItem); // 원본 배열 수정
      setItems(items);     // React가 변경 감지 못 함
    };

    // ✅ 올바른 예: 불변성 유지
    const handleAddItem = () => {
      setItems([...items, newItem]); // 새로운 배열 생성
    };

    // 복잡한 상태 업데이트
    const handleUpdateUser = (userId, updates) => {
      setUsers(users.map(user =>
        user.id === userId
          ? { ...user, ...updates } // 객체 불변성도 유지
          : user
      ));
    };
    ```

    #### 성능 고려사항

    - **작은 배열**: 불변성 유지 비용이 적음
    - **큰 배열**: `splice`가 더 효율적일 수 있지만, 신중하게 사용
    - **Immutable.js나 Immer**: 대규모 애플리케이션에서 구조적 공유를 통한 최적화

    ```javascript
    // Immer를 사용한 편리한 불변성 유지
    import { produce } from 'immer';

    const handleComplexUpdate = () => {
      setState(produce(draft => {
        draft.users[0].profile.name = '새 이름';
        draft.settings.theme = 'dark';
        // 복잡한 중첩 구조도 쉽게 수정 가능
      }));
    };
    ```
  </TabsContent>

  <TabsContent value='performance'>
    ### 성능 고려사항

    - **대용량 배열**: `splice`는 직접 수정이므로 가장 빠름
    - **불변성 필요**: `map`, `filter`, `reduce` 사용
    - **메모리 사용**: 새로운 배열 생성 메서드들은 추가 메모리 소요
    - **체이닝**: 메서드 체이닝 시 중간 배열 생성에 주의

    ```javascript
    // 비효율적인 체이닝 (중간 배열 3개 생성)
    const result = array
      .map(item => item.value)
      .filter(value => value > 10)
      .reduce((sum, value) => sum + value, 0);

    // 최적화된 reduce 사용 (중간 배열 없음)
    const optimized = array.reduce((sum, item) => {
      if (item.value > 10) {
        return sum + item.value;
      }
      return sum;
    }, 0);
    ```

  </TabsContent>
</Tabs>

## 실전 팁과 모범 사례

<Steps>
  <Step title="불변성 유지하기">
    가능하다면 `splice` 대신 `map`, `filter`, `reduce`를 사용하세요. React와 같은 라이브러리에서는 불변성이 중요합니다.

    ```javascript
    // ❌ 좋지 않은 예
    const addItem = (array, item) => {
      array.push(item); // 원본 수정
      return array;
    };

    // ✅ 좋은 예
    const addItem = (array, item) => [...array, item]; // 불변성 유지
    ```

  </Step>

  <Step title="타입 안전성 확보">
    TypeScript를 사용할 때는 제네릭을 활용하여 타입 안정성을 높이세요.

    ```typescript
    interface User {
      id: number;
      name: string;
      age: number;
    }

    const users: User[] = [/* ... */];

    // 타입 추론이 제대로 작동함
    const names = users.map(user => user.name); // string[]
    const adults = users.filter(user => user.age >= 18); // User[]
    ```

  </Step>

  <Step title="에러 처리">
    배열 메서드 사용 시 예외 상황을 고려하세요.

    ```javascript
    // 안전한 reduce 사용
    const safeSum = (numbers: number[]) => {
      return numbers?.reduce((sum, num) => sum + num, 0) ?? 0;
    };

    // 빈 배열 처리
    const getFirstEven = (numbers: number[]) => {
      return numbers.find(num => num % 2 === 0) ?? null;
    };
    ```

  </Step>

  <Step title="메서드 체이닝">
    적절한 체이닝으로 코드 가독성을 높이세요.

    ```javascript
    const result = users
      .filter(user => user.isActive)
      .map(user => ({
        id: user.id,
        displayName: `${user.firstName} ${user.lastName}`
      }))
      .sort((a, b) => a.displayName.localeCompare(b.displayName));
    ```

  </Step>
</Steps>

## 결론

JavaScript의 `map`, `filter`, `reduce`, `splice`는 배열을 효과적으로 다루기 위한 핵심 메서드들입니다. 각 메서드의 특징을 이해하고 적절한 상황에 맞게 사용한다면 더 깔끔하고 효율적인 코드를 작성할 수 있습니다.

<Callout type='success' title='다음 단계'>
  이 메서드들을 익혔다면 이제 `find`, `some`, `every`, `flatMap` 등의 다른 배열
  메서드들도 공부해보세요. 또한 함수형 프로그래밍 개념과 결합하면 더욱 강력한
  코드를 작성할 수 있습니다.
</Callout>

<ReferenceList title='참고 자료'>
  <Reference
    title='MDN Web Docs - Array'
    description='JavaScript 배열 메서드의 공식 문서'
    href='https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array'
    type='documentation'
  />
  <Reference
    title='JavaScript.info - Array methods'
    description='배열 메서드에 대한 상세한 설명과 예제'
    href='https://ko.javascript.info/array-methods'
    type='tutorial'
  />
  <Reference
    title='Functional Programming in JavaScript'
    description='함수형 프로그래밍 관점에서의 배열 메서드 활용'
    href='https://github.com/MostlyAdequate/mostly-adequate-guide'
    type='book'
  />
</ReferenceList>
