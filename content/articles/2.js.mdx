# Episode 2: "자바스크립트의 우연한 제국"

_10일 만에 만든 언어가 세상을 지배하기까지_

import {
  Callout,
  Steps,
  Step,
  Blockquote,
  Badge,
  Card,
  Reference,
  ReferenceList,
} from '@/components/writing-ui';

---

## 프롤로그: 우연히 시작된 혁명

1995년 5월, 넷스케이프의 한 개발자가 단 10일 만에 만든 프로그래밍 언어가 있었습니다. 당시에는 "웹 페이지에 약간의 상호작용을 추가하는" 용도로 만들어진 이 언어가, 30년이 지난 지금은 전 세계 소프트웨어 개발의 중심에 서 있습니다.

이것은 자바스크립트의 이야기입니다. 그리고 이것은 실수와 타협, 우연과 필연이 만들어낸 가장 놀라운 성공 스토리 중 하나입니다.

<Callout type='note' title='이 글에서 다룰 내용'>
  - 브렌든 아이크의 10일간의 광기어린 개발 - "웹 페이지 장식용"에서 "풀스택
  언어"로의 진화 - V8 엔진이 가져온 성능 혁명 - Node.js로 인한 브라우저 감옥
  탈출기
</Callout>

---

## Chapter 1: 브렌든 아이크의 10일간의 광기

### 1995년, 웹의 새벽

1995년의 웹은 지금과는 완전히 다른 세상이었습니다. HTML로 만든 정적인 페이지들이 전부였고, 사용자와의 상호작용이라고는 하이퍼링크를 클릭하는 것이 고작이었죠. 마치 움직이지 않는 잡지를 보는 것과 같았습니다.

넷스케이프는 이 상황을 바꾸고 싶었습니다. 웹 페이지에 생동감을 불어넣고, 사용자와 상호작용할 수 있는 무언가가 필요했죠.

<Card title='1995년 웹의 풍경' description='정적 HTML 시대의 특징들'>
  - **단방향 소통**: 서버에서 브라우저로만 정보 전달 - **페이지 새로고침**: 모든
  상호작용은 전체 페이지 리로드 필요 - **폼 제출**: 유일한 사용자 입력 방법 -
  **제한된 스타일링**: CSS도 아직 표준화되지 않음
</Card>

### 10일의 기적

1995년 5월, 브렌든 아이크(Brendan Eich)라는 34세의 개발자가 넷스케이프에 입사했습니다. 그에게 주어진 미션은 명확했습니다: **"스킴(Scheme) 같은 언어를 브라우저에 넣어라. 그런데 자바처럼 보이게 만들어라. 그리고 10일 안에."**

<Blockquote author='브렌든 아이크' cite='JavaScript: The First 20 Years'>
  "나는 10일 안에 자바스크립트를 만들어야 했다. 만약 더 많은 시간이 있었다면,
  아마 더 나쁜 언어를 만들었을 것이다."
</Blockquote>

이 10일 동안 아이크가 해야 했던 일들을 상상해보세요:

<Steps>
<Step title="언어 문법 설계">
C와 자바에서 영감을 받은 문법 구조 설계
</Step>

<Step title='타입 시스템 결정'>
  동적 타입 시스템과 자동 타입 변환 규칙 정의
</Step>

<Step title='객체 모델 구현'>프로토타입 기반 상속 시스템 개발</Step>

<Step title="브라우저 통합">
DOM 조작과 이벤트 처리 시스템 구축
</Step>
</Steps>

### 타협의 산물

아이크는 여러 언어에서 아이디어를 빌려왔습니다:

- **자바**: 문법과 이름 (마케팅적 이유)
- **스킴**: 함수형 프로그래밍 요소와 일급 함수
- **셀프**: 프로토타입 기반 객체 지향
- **펄**: 정규표현식과 유연한 문법

<Callout type='warning' title='시간 압박의 결과'>
  10일이라는 촉박한 시간 때문에 자바스크립트에는 여러 설계상의 문제들이 남게
  되었습니다. `==`와 `===`의 차이, 호이스팅(hoisting), `this` 바인딩의 복잡성
  등이 그 예입니다.
</Callout>

---

## Chapter 2: "웹 페이지 장식용"에서 "풀스택 언어"까지

### 초기의 용도: 단순한 스크립팅

처음 자바스크립트는 정말 간단한 일들만 했습니다:

```javascript
// 1995년 자바스크립트의 전형적인 사용법
function validateForm() {
  if (document.forms[0].name.value == '') {
    alert('이름을 입력하세요!');
    return false;
  }
  return true;
}

// 마우스 오버 효과
function changeImage(img, newSrc) {
  img.src = newSrc;
}
```

이런 "장난감" 수준의 사용법이 대부분이었죠. 진짜 개발자들은 자바스크립트를 진지하게 받아들이지 않았습니다.

### AJAX: 게임 체인저의 등장

2005년, 제시 제임스 가렛(Jesse James Garrett)이 "AJAX"라는 용어를 만들어냈습니다. 사실 기술 자체는 마이크로소프트가 1999년에 만든 `XMLHttpRequest`였지만, 구글이 Gmail과 Google Maps에서 이를 활용하면서 웹 개발의 패러다임이 완전히 바뀌었습니다.

<Card title="AJAX 이전 vs 이후" description="웹 애플리케이션의 진화">

**AJAX 이전:**

- 클릭 → 전체 페이지 새로고침 → 응답 표시
- 서버 중심적 사고
- 페이지 = 문서

**AJAX 이후:**

- 백그라운드 데이터 요청
- 부분적 페이지 업데이트
- 애플리케이션 = 프로그램

</Card>

### jQuery의 등장: "Write Less, Do More"

2006년, 존 레식(John Resig)이 발표한 jQuery는 자바스크립트 생태계를 완전히 바꿔놓았습니다.

```javascript
// Vanilla JavaScript (2006년 스타일)
var elements = document.getElementsByTagName('div');
for (var i = 0; i < elements.length; i++) {
  if (elements[i].className.indexOf('highlight') !== -1) {
    elements[i].style.backgroundColor = 'yellow';
    elements[i].addEventListener('click', function () {
      this.style.display = 'none';
    });
  }
}

// jQuery
$('.highlight')
  .css('background-color', 'yellow')
  .click(function () {
    $(this).hide();
  });
```

jQuery는 자바스크립트를 대중화시켰습니다. 갑자기 모든 웹 디자이너가 "프로그래머"가 될 수 있었죠.

<Callout type='success' title='jQuery의 기여'>
  - **크로스 브라우저 호환성**: IE6부터 최신 브라우저까지 동일한 API - **간결한
  문법**: 복잡한 DOM 조작을 한 줄로 - **플러그인 생태계**: 수천 개의 재사용
  가능한 컴포넌트 - **학습 곡선 완화**: 비프로그래머도 쉽게 접근 가능
</Callout>

---

## Chapter 3: V8 엔진: 인터프리터에서 JIT의 기적

### 느린 자바스크립트의 한계

2008년 이전까지 자바스크립트는 정말 느렸습니다. 모든 브라우저가 단순한 인터프리터를 사용했고, 복잡한 연산은 꿈도 꿀 수 없었죠.

```javascript
// 이런 코드는 2007년에는 브라우저를 멈추게 만들었습니다
function fibonacci(n) {
  if (n < 2) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.time('fib');
fibonacci(40); // 몇 초간 브라우저 정지
console.timeEnd('fib');
```

### 구글의 야심찬 도전

구글은 Gmail, Google Maps 같은 웹 애플리케이션을 만들면서 자바스크립트 성능의 한계를 절실히 느꼈습니다. 그래서 결정했죠: **"우리가 직접 자바스크립트 엔진을 만들자."**

라스 바크(Lars Bak)가 이끄는 V8 팀이 설정한 목표는 명확했습니다:

<Badge variant='success'>10배 빠른 자바스크립트</Badge>

### JIT 컴파일의 마법

V8의 핵심 혁신은 **JIT(Just-In-Time) 컴파일**이었습니다. 이는 코드를 실행하면서 동시에 컴파일하는 기술입니다.

<Steps>
<Step title="초기 실행">
코드를 빠르게 해석하여 실행 시작
</Step>

<Step title='프로파일링'>어떤 함수가 자주 호출되는지 분석</Step>

<Step title='최적화'>자주 사용되는 코드를 네이티브 머신 코드로 컴파일</Step>

<Step title="적응적 최적화">
실행 패턴이 바뀌면 다시 최적화
</Step>
</Steps>

### 성능 혁명의 결과

V8의 등장은 자바스크립트 세계에 충격을 안겨주었습니다:

```javascript
// 갑자기 이런 복잡한 연산도 가능해졌습니다
function mandelbrot(width, height, maxIter) {
  const result = new Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      // 복잡한 수학 연산...
      result[y * width + x] = calculatePoint(x, y, maxIter);
    }
  }
  return result;
}

// 2008년 이전: 불가능
// 2008년 이후: 실시간 처리 가능
```

<Callout type='info' title='V8의 파급효과'>
  V8의 성공을 보고 다른 브라우저 제조사들도 경쟁적으로 JIT 엔진을 개발했습니다:
  - **Firefox**: TraceMonkey → JägerMonkey → IonMonkey - **Safari**: Nitro
  (SquirrelFish Extreme) - **Internet Explorer**: Chakra
</Callout>

---

## Chapter 4: Node.js: 브라우저 감옥에서 탈출한 JS

### 2009년, 라이언 달의 깨달음

라이언 달(Ryan Dahl)은 파일 업로드 진행률을 보여주는 웹 애플리케이션을 만들다가 좌절했습니다. 기존의 웹 서버들은 모두 **블로킹(blocking) I/O**를 사용했고, 이는 동시에 많은 연결을 처리하기에는 너무 비효율적이었습니다.

<Card title="전통적인 서버의 문제" description="멀티스레드 모델의 한계">

```
클라이언트 1 요청 → 스레드 1 생성 → 파일 읽기 대기 (블록됨)
클라이언트 2 요청 → 스레드 2 생성 → DB 쿼리 대기 (블록됨)
클라이언트 3 요청 → 스레드 3 생성 → 네트워크 요청 대기 (블록됨)
...
메모리 부족!
```

</Card>

### 비동기 I/O의 아이디어

라이언은 다른 접근 방식을 생각했습니다: **"모든 I/O를 비동기로 처리하면 어떨까?"**

```javascript
// 전통적인 동기 방식 (블로킹)
const data = fs.readFileSync('huge-file.txt'); // 여기서 멈춤
console.log('파일 읽기 완료');

// Node.js 비동기 방식 (논블로킹)
fs.readFile('huge-file.txt', (err, data) => {
  console.log('파일 읽기 완료');
});
console.log('이 코드는 바로 실행됨'); // 먼저 출력됨!
```

### V8 + Event Loop = Node.js

라이언은 V8 엔진과 이벤트 루프를 결합해서 Node.js를 만들었습니다. 자바스크립트가 브라우저를 벗어나 서버에서 실행될 수 있게 된 순간이었죠.

<Blockquote author='라이언 달' cite='Node.js 초기 발표'>
  "I/O는 느리다. 그러니까 I/O를 기다리지 말자. 다른 일을 하면서 I/O가 끝나면
  콜백을 호출하자."
</Blockquote>

### NPM: 패키지 생태계의 폭발

2010년, 아이작 슐루터(Isaac Schlueter)가 NPM(Node Package Manager)을 만들었습니다. 이는 자바스크립트 생태계에 또 다른 혁명을 가져왔습니다.

```bash
# 2010년 이전: 라이브러리 사용이 복잡했음
# 1. 웹사이트에서 다운로드
# 2. 압축 해제
# 3. 수동으로 프로젝트에 복사
# 4. HTML에서 스크립트 태그로 로드

# 2010년 이후: 한 줄이면 끝
npm install express
```

<Callout type="success" title="NPM의 기하급수적 성장">
- **2011년**: 1,000개 패키지
- **2013년**: 50,000개 패키지  
- **2016년**: 300,000개 패키지
- **2024년**: 2,000,000개 이상 패키지

현재 NPM은 세계에서 가장 큰 소프트웨어 레지스트리입니다.

</Callout>

### 풀스택 자바스크립트의 시대

Node.js의 등장으로 이제 자바스크립트로 모든 것을 할 수 있게 되었습니다:

<Steps>
<Step title="프론트엔드">
React, Vue, Angular로 사용자 인터페이스 구축
</Step>

<Step title='백엔드'>Express, Fastify로 API 서버 개발</Step>

<Step title='데이터베이스'>MongoDB, CouchDB 같은 JSON 기반 데이터베이스</Step>

<Step title='모바일'>React Native, Ionic으로 모바일 앱 개발</Step>

<Step title="데스크톱">
Electron으로 크로스 플랫폼 데스크톱 앱
</Step>
</Steps>

---

## Chapter 5: 현재와 미래: 자바스크립트 제국의 확장

### ES6+: 언어 자체의 진화

2015년 ES6(ES2015)의 등장으로 자바스크립트는 "진짜" 프로그래밍 언어로 거듭났습니다:

```javascript
// ES5 시대의 코드
function createCounter() {
  var count = 0;
  return {
    increment: function () {
      count++;
      return count;
    },
    get: function () {
      return count;
    },
  };
}

// ES6+ 시대의 코드
class Counter {
  #count = 0;

  increment() {
    return ++this.#count;
  }

  get value() {
    return this.#count;
  }
}

const counter = new Counter();
```

### 타입스크립트: 안전성의 추가

마이크로소프트의 타입스크립트는 자바스크립트에 정적 타입을 추가했습니다:

```typescript
// 자바스크립트: 런타임에 오류 발견
function calculateArea(radius) {
  return Math.PI * radius * radius;
}
calculateArea('hello'); // 런타임 오류!

// 타입스크립트: 컴파일 타임에 오류 발견
function calculateArea(radius: number): number {
  return Math.PI * radius * radius;
}
calculateArea('hello'); // 컴파일 오류!
```

### 웹 표준의 진화

자바스크립트는 이제 웹 플랫폼의 핵심이 되었습니다:

<Card title='최신 웹 API들' description='자바스크립트로 할 수 있는 일들'>
  - **WebAssembly**: 네이티브급 성능 - **Service Workers**: 오프라인 웹 앱 -
  **WebRTC**: 실시간 통신 - **Web Workers**: 멀티스레딩 - **WebGL**: 3D 그래픽스
  - **Web Audio API**: 오디오 처리
</Card>

---

## 에필로그: 우연이 만든 필연

브렌든 아이크가 10일 만에 만든 "웹 페이지 장식용" 언어가 어떻게 세상을 지배하게 되었을까요?

### 성공의 요인들

1. **적절한 타이밍**: 웹의 폭발적 성장과 함께
2. **접근성**: 컴파일 없이 바로 실행 가능
3. **유연성**: 함수형, 객체지향, 절차적 프로그래밍 모두 지원
4. **생태계**: 거대한 오픈소스 커뮤니티
5. **적응력**: 계속 진화하는 언어 사양

<Callout type='note' title='아이러니한 성공'>
  자바스크립트의 성공은 그 완벽함이 아니라 불완전함에서 나왔을지도 모릅니다.
  유연함과 관대함이 더 많은 사람들을 프로그래밍 세계로 끌어들였고, 그것이 거대한
  생태계를 만들어냈습니다.
</Callout>

### 미래를 향해

자바스크립트는 여전히 진화하고 있습니다:

- **웹어셈블리와의 협력**: 성능이 중요한 부분은 WASM으로
- **AI와의 결합**: 브라우저에서 돌아가는 머신러닝
- **IoT 확장**: Node.js가 임베디드 시스템으로
- **블록체인**: Web3 생태계의 중심 언어

10일 만에 만든 언어가 30년 후에도 여전히 혁신을 주도하고 있다는 것은 정말 놀라운 일입니다. 브렌든 아이크는 아마 자신이 얼마나 큰 일을 해냈는지 상상도 못했을 것입니다.

<Blockquote author='브렌든 아이크' cite='2020년 인터뷰'>
  "자바스크립트가 이렇게 성공할 줄 몰랐다. 하지만 웹이 성공했기 때문에
  자바스크립트도 성공했다. 웹의 성공이 곧 자바스크립트의 성공이었다."
</Blockquote>

---

<ReferenceList title='참고자료'>
  <Reference
    title='JavaScript: The First 20 Years'
    description='자바스크립트 역사에 대한 공식 문서'
    href='https://dl.acm.org/doi/10.1145/3386327'
    type='documentation'
    author='Allen Wirfs-Brock, Brendan Eich'
  />
  <Reference
    title='The Birth of Node.js'
    description='라이언 달의 Node.js 개발 이야기'
    href='https://nodejs.org/en/about/'
    type='article'
    author='Ryan Dahl'
  />
  <Reference
    title='V8 JavaScript Engine'
    description='V8 엔진의 기술적 세부사항'
    href='https://v8.dev/'
    type='documentation'
    author='Google V8 Team'
  />
  <ReferenceList
    title='jQuery History'
    description='jQuery의 탄생과 발전사'
    href='https://jquery.com/'
    type='tutorial'
    author='John Resig'
  />
</ReferenceList>

---

_다음 에피소드에서는 "깃의 탄생: 리누스의 두 번째 혁명"을 다룰 예정입니다. 2주 만에 만든 버전 관리 시스템이 어떻게 전 세계 개발자들의 협업 방식을 바꿨는지 살펴보겠습니다._
