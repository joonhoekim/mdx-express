---
title: 'TypeScript 풀스택 개발에서 피해야 할 것들'
description: '직접 겪은 실수와 교훈들 - 데이터베이스 뷰, 컴포넌트 폭발 등'
date: '2025-10-15'
tags: ['TypeScript', '풀스택', 'ORM', 'React', '회고']
---

import { Callout } from '@/components/writing-ui';

TypeScript 기반 풀스택 개발을 하면서 겪은 실수들을 정리합니다. 당시에는 합리적인 선택이라 생각했지만, 결과적으로 유지보수를 어렵게 만든 결정들입니다.

## 1. 데이터베이스 뷰를 사용하지 마라

Drizzle 같은 ORM을 사용할 때 데이터베이스 뷰(View)를 활용하고 싶은 유혹이 있습니다. 복잡한 조인이나 집계를 뷰로 만들어두면 쿼리가 간단해지니까요.

하지만 이 접근 방식에는 심각한 문제가 있습니다.

### 왜 문제인가

<Callout type='warning' title='핵심 문제'>
  뷰는 단일 책임 원칙(SRP)을 위반하게 만듭니다. 스키마를 수정하면 뷰와 애플리케이션을 둘 다 수정해야 합니다.
</Callout>

**문제 1: 단일 책임 원칙 위반**

뷰를 사용하는 순간, 데이터 조회 로직의 책임이 두 곳으로 분산됩니다:

```
스키마 변경 발생
→ 뷰 정의 수정 필요
→ 애플리케이션 코드도 수정 필요
→ 변경 지점이 2배로 증가
→ 하나라도 놓치면 런타임 에러
```

이것이 가장 치명적인 문제입니다. 테이블 컬럼 하나 바꾸는데 뷰도 확인하고, 애플리케이션도 확인해야 합니다. 뷰가 여러 개면 더 심각해집니다.

**문제 2: 성능에 도움이 안 됨**

흔한 오해가 "뷰를 쓰면 성능이 좋아진다"는 것입니다. 틀렸습니다.

일반 뷰는 매번 쿼리를 실행합니다. 캐싱도 없고, 최적화도 없습니다. 그냥 SQL을 숨겨놓은 것일 뿐입니다.

Materialized View는 결과를 저장하므로 성능에 도움이 됩니다. 하지만 Materialized View가 필요한 상황이라면, 대부분 설계 자체를 재검토해야 할 신호입니다. 정말 필요한 게 맞는지 먼저 고민해야 합니다.

**문제 3: ORM과의 불협화음**

Drizzle이나 Prisma 같은 ORM은 테이블 스키마를 기준으로 타입을 생성합니다. 뷰를 사용하면:

- 타입 추론이 제대로 되지 않거나 수동 정의가 필요
- 마이그레이션 관리가 복잡해짐
- ORM의 relation 기능을 활용하기 어려움

**문제 4: 로직의 은닉**

```
애플리케이션 코드에서 비즈니스 로직 일부 처리
→ 나머지는 DB 뷰에서 처리
→ 디버깅 시 양쪽을 모두 확인해야 함
→ 전체 로직 파악이 어려움
```

### 대안: 애플리케이션에 책임을 위임하라

```typescript
// Bad: 뷰에 의존
const orderSummary = await db.select().from(orderSummaryView);

// Good: 애플리케이션에서 명시적으로 처리
const orders = await db
  .select({
    orderId: ordersTable.id,
    customerName: customersTable.name,
    totalAmount: sql<number>`sum(${orderItemsTable.price})`,
  })
  .from(ordersTable)
  .innerJoin(customersTable, eq(ordersTable.customerId, customersTable.id))
  .innerJoin(orderItemsTable, eq(ordersTable.id, orderItemsTable.orderId))
  .groupBy(ordersTable.id, customersTable.name);
```

쿼리가 길어지더라도 모든 로직이 한 곳에 있으면:

- 코드 리뷰가 쉬워짐
- 타입 안전성 확보
- 테스트 작성이 용이
- 성능 튜닝 포인트가 명확

<Callout type='info' title='예외 상황'>
  레거시 시스템 연동이나 리포팅 전용 뷰처럼, 읽기 전용이고 변경 가능성이 낮은 경우에는 뷰가 적절할 수 있습니다.
</Callout>

## 2. 컴포넌트 폭발을 경계하라

React 컴포넌트를 "작고 재사용 가능하게" 만들라는 원칙을 과하게 적용하면 컴포넌트 폭발(Component Explosion)이 발생합니다.

### 컴포넌트 폭발이란

하나의 기능을 위해 과도하게 많은 컴포넌트 파일이 생기는 현상입니다.

```
components/
  UserProfile/
    UserProfile.tsx
    UserProfileContainer.tsx
    UserProfileHeader.tsx
    UserProfileHeaderTitle.tsx
    UserProfileHeaderSubtitle.tsx
    UserProfileBody.tsx
    UserProfileAvatar.tsx
    UserProfileAvatarWrapper.tsx
    UserProfileStats.tsx
    UserProfileStatItem.tsx
    ...
```

### 왜 문제인가

<Callout type='error' title='실제로 겪은 문제'>
  컴포넌트가 100개가 넘어가면서 간단한 UI 수정에도 5~6개 파일을 열어봐야 했습니다. props drilling도 심해지고, 어떤 컴포넌트가 어디서 쓰이는지 파악하기 어려워졌습니다.
</Callout>

**문제 1: 인지 부하 증가**

- 파일 간 이동이 잦아짐
- 데이터 흐름 추적이 어려움
- 새로운 팀원의 온보딩 시간 증가

**문제 2: 재사용의 환상**

"나중에 재사용하겠지"라고 만든 컴포넌트 중 실제로 재사용되는 비율은 극히 낮습니다. 오히려 재사용을 위해 추가한 props들이 컴포넌트를 복잡하게 만듭니다.

**문제 3: 추상화 비용**

컴포넌트 분리는 공짜가 아닙니다:

- 파일 생성 및 관리 비용
- import/export 관리
- props 인터페이스 정의
- 테스트 파일 증가

### 대안: 적절한 크기를 유지하라

```tsx
// Bad: 과도한 분리
<UserProfileContainer>
  <UserProfileHeader>
    <UserProfileHeaderTitle>{user.name}</UserProfileHeaderTitle>
  </UserProfileHeader>
</UserProfileContainer>

// Good: 적절한 응집도
<UserProfile user={user} />

// UserProfile 내부에서 필요한 만큼만 분리
function UserProfile({ user }: { user: User }) {
  return (
    <div className="profile">
      <header>
        <h1>{user.name}</h1>
        <p>{user.bio}</p>
      </header>
      <UserStats stats={user.stats} />
    </div>
  );
}
```

**컴포넌트 분리 기준:**

1. **실제로 재사용되는가?** - 2곳 이상에서 사용될 때 분리
2. **독립적인 상태를 가지는가?** - 자체 상태 관리가 필요하면 분리
3. **테스트가 필요한가?** - 복잡한 로직이 있으면 분리
4. **가독성이 나아지는가?** - 100줄이 넘어가면 분리 고려

<Callout type='success' title='실용적인 원칙'>
  "컴포넌트를 분리해야 할 이유가 명확할 때만 분리하라." 분리하지 않을 이유를 찾지 말고, 분리해야 할 이유를 찾아라.
</Callout>

## 3. 메뉴는 처음부터 동적으로 관리하라

정말 작은 프로젝트가 아니라면, 메뉴를 하드코딩하지 마세요. 결국 나중에 다 바꾸게 됩니다.

### 반드시 나오는 요구사항들

프로젝트가 조금만 커지면 이런 요청이 들어옵니다:

- "메뉴를 직접 수정하고 싶어요" (관리자 페이지에서)
- "페이지 제목을 메뉴 이름이랑 맞춰주세요"
- "SEO를 위해 메뉴별로 metadata를 다르게 설정해주세요"
- "다국어 지원할 때 메뉴도 언어별로 바뀌어야 해요"
- "메뉴 순서를 드래그로 바꾸고 싶어요"

<Callout type='warning' title='핵심 문제'>
  메뉴를 하드코딩하면, 위 요구사항 하나하나가 대규모 리팩토링을 요구합니다. 모든 페이지를 돌아다니며 수정해야 합니다.
</Callout>

### 흔한 실수: 페이지마다 개별 처리

```tsx
// pages/dashboard.tsx
export const metadata = {
  title: '대시보드',
  description: '대시보드 페이지입니다',
};

// pages/users.tsx
export const metadata = {
  title: '사용자 관리',
  description: '사용자를 관리합니다',
};

// pages/settings.tsx
export const metadata = {
  title: '설정',
  description: '설정 페이지입니다',
};

// ... 페이지가 50개면 50군데 수정
```

이렇게 하면:

- 메뉴 이름 바꾸려면 해당 페이지 파일 직접 수정 필요
- 다국어 지원하려면 모든 페이지에 i18n 로직 추가
- 관리자가 메뉴를 수정하려면 배포가 필요
- 메뉴 구조와 페이지 구조가 분리되어 불일치 발생

### 대안: DB + Layout에서 일괄 처리

```tsx
// DB에 메뉴 정보 저장
// menus 테이블: id, path, title, description, order, parent_id, locale

// layout.tsx 또는 template.tsx에서 일괄 처리
async function RootLayout({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const locale = useLocale();

  // 현재 경로에 해당하는 메뉴 정보 조회
  const menuInfo = await getMenuByPath(pathname, locale);

  return (
    <html>
      <head>
        <title>{menuInfo?.title}</title>
        <meta name="description" content={menuInfo?.description} />
      </head>
      <body>
        <Sidebar menus={await getMenuTree(locale)} />
        {children}
      </body>
    </html>
  );
}
```

이렇게 하면:

- 메뉴 수정은 DB 업데이트만으로 해결
- 다국어는 locale 컬럼으로 자연스럽게 지원
- 관리자 페이지에서 CRUD 가능
- 메뉴와 페이지 metadata가 항상 일치

### 보너스: 권한 관리가 쉬워진다

메뉴를 DB로 관리하면, 권한 관리 요구사항이 들어왔을 때 자연스럽게 확장할 수 있습니다.

```sql
-- 역할-메뉴 매핑 테이블만 추가하면 됨
CREATE TABLE role_menus (
  role_id INT REFERENCES roles(id),
  menu_id INT REFERENCES menus(id),
  PRIMARY KEY (role_id, menu_id)
);
```

```tsx
// layout.tsx에서 권한 체크 추가
async function RootLayout({ children }: { children: React.ReactNode }) {
  const user = await getUser();
  const menus = await getMenuTreeByRole(user.roleId, locale);

  // 권한 없는 메뉴는 애초에 조회되지 않음
  return (
    <Sidebar menus={menus} />
  );
}
```

메뉴를 하드코딩했다면? 모든 페이지에 권한 체크 로직을 추가하고, 사이드바 컴포넌트에서도 조건부 렌더링을 넣고, 관리자 페이지에서 역할별 메뉴를 설정하는 UI도 따로 만들어야 합니다.

DB로 관리했다면? 테이블 하나 추가하고 쿼리만 수정하면 끝입니다.

### 구현 포인트

**1. 메뉴 테이블 설계**

```sql
CREATE TABLE menus (
  id SERIAL PRIMARY KEY,
  path VARCHAR(255) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  icon VARCHAR(50),
  order_index INT DEFAULT 0,
  parent_id INT REFERENCES menus(id),
  locale VARCHAR(10) DEFAULT 'ko',
  is_visible BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**2. generateMetadata에서 메뉴 정보 활용 (Next.js)**

```tsx
// app/[...slug]/page.tsx
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const menu = await getMenuByPath(`/${params.slug.join('/')}`);

  return {
    title: menu?.title ?? 'Default Title',
    description: menu?.description,
  };
}
```

**3. 메뉴 캐싱**

메뉴는 자주 변경되지 않으므로 적극적으로 캐싱하세요:

```typescript
const getMenuTree = cache(async (locale: string) => {
  return db.select().from(menus).where(eq(menus.locale, locale));
});
```

<Callout type='success' title='실용적인 원칙'>
  "나중에 동적으로 바꾸면 되지"라고 생각하면, 그 '나중'이 오면 모든 페이지를 수정해야 합니다. 처음부터 DB로 관리하세요.
</Callout>

## 4. 비즈니스 로직과 레거시를 먼저 분석하라

어찌 보면 당연한 말입니다. 하지만 일정에 쫓기다 보면 "일단 만들고 맞추자"는 유혹에 빠지기 쉽습니다.

### 분석 없이 구현하면 생기는 일

<Callout type='error' title='실제로 겪은 일'>
  요구사항 문서만 보고 "대충 이런 거겠지" 하며 구현했습니다. 결과물을 보여주니 "이게 아닌데요"라는 말을 들었습니다. 절반 이상을 다시 만들었습니다.
</Callout>

```
요구사항 문서만 보고 구현 시작
→ 실제 업무 프로세스와 맞지 않음
→ 현업 피드백: "이게 아닌데요"
→ 대규모 수정 또는 재구현
→ 일정 지연 + 신뢰 하락
```

비즈니스 로직을 제대로 이해하지 않으면, 기술적으로 아무리 잘 만들어도 쓸모없는 프로그램이 됩니다.

### 요구사항 문서를 믿지 마라

현실적인 조언입니다. 요구사항 문서 자체가 형편없는 경우가 많습니다.

<Callout type='warning' title='현실'>
  고객사의 "IT 담당자"라는 사람들도 대부분은 코드 짤 줄 모릅니다. 그들의 역할은 프로젝트 계약과 일정 관리입니다. 실제 업무를 아는 사람은 현업 담당자입니다.
</Callout>

요구사항 문서는 현업 → IT 담당자 → 문서화 과정을 거치면서 왜곡됩니다. 중간에 정보가 빠지고, 잘못 해석되고, 추상화됩니다.

**그래서 해야 할 일:**

1. **기존 시스템을 직접 봐라** - 현재 쓰고 있는 엑셀, 레거시 시스템, 수기 문서 등을 직접 확인
2. **현업 담당자와 직접 대화하라** - IT 담당자를 통하지 말고 실제 업무를 하는 사람과 이야기
3. **업무를 따라가 봐라** - 가능하다면 하루 정도 옆에서 실제 업무 프로세스를 관찰

```
요구사항 문서: "주문 정보를 관리한다"
↓
현업과 대화 후: "주문은 5가지 상태가 있고,
                취소는 배송 전에만 가능하며,
                부분 취소 시 금액 재계산이 필요하고,
                환불은 별도 승인 프로세스를 거친다"
```

문서에 한 줄로 적힌 기능이 실제로는 수십 가지 규칙을 포함하고 있습니다. 이걸 모르고 구현하면 "이게 아닌데요"를 듣게 됩니다.

### DB 설계: 레거시와 동일하게 가져가라

시간이 충분하면 이상적인 스키마를 설계할 수 있습니다. 하지만 현실은 대부분 시간이 부족합니다.

<Callout type='warning' title='흔한 실수'>
  "레거시 구조가 마음에 안 드니까 새로 설계하고 매핑하면 되지"라는 생각은 하수의 판단입니다.
</Callout>

**"매핑하면 되지"가 잡아먹는 비용:**

1. **인지적 비용**: 두 가지 스키마를 동시에 머릿속에 담고 있어야 함
2. **매핑 로직 구현**: 양방향 변환 코드 작성 및 유지보수
3. **디버깅 복잡도**: 문제 발생 시 어느 쪽 스키마 기준인지 확인 필요
4. **엣지 케이스**: 레거시에만 있는 예외 상황을 새 스키마에서 표현 못 함
5. **테스트 부담**: 매핑 정합성 테스트까지 추가

```typescript
// Bad: "우리 스키마"로 만들고 매핑
const legacyOrder = await fetchFromLegacy(orderId);
const ourOrder = mapLegacyToOur(legacyOrder);  // 여기서 문제 발생
const result = processOrder(ourOrder);
const legacyResult = mapOurToLegacy(result);   // 여기서도 문제 발생
await sendToLegacy(legacyResult);

// Good: 레거시와 동일한 구조 사용
const order = await fetchFromLegacy(orderId);
const result = processOrder(order);  // 같은 구조니까 바로 처리
await sendToLegacy(result);
```

### 언제 새로 설계해도 되는가

- 레거시 시스템과 인터페이스가 없는 경우
- 충분한 분석 및 설계 시간이 확보된 경우
- 레거시 구조가 명백히 잘못되어 마이그레이션이 필수인 경우

이 조건을 만족하지 않으면, 레거시 테이블 구조를 그대로 가져가는 게 현명합니다. 테이블명, 컬럼명까지 동일하게 맞추세요. "나중에 정리하지 뭐"라고 생각하면 그 '나중'은 오지 않습니다.

<Callout type='success' title='실용적인 원칙'>
  시간이 부족하면 이상적인 설계를 포기하세요. 레거시와 100% 동일하게 맞추는 게 훨씬 빠르고 안전합니다.
</Callout>

## 5. 에러 핸들링을 한 곳에서 처리하라

API 호출마다 try-catch를 개별로 작성하고 있다면, 나중에 고통받을 준비를 하고 있는 겁니다.

### 흔한 실수: 에러 처리 코드의 복붙

```tsx
// 페이지 A
try {
  const data = await fetchUsers();
} catch (error) {
  toast.error('사용자 정보를 불러오는데 실패했습니다.');
  console.error(error);
}

// 페이지 B
try {
  const data = await fetchOrders();
} catch (error) {
  toast.error('주문 정보를 불러오는데 실패했습니다.');
  console.error(error);
}

// ... 50개 페이지에 비슷한 코드
```

그러다 이런 요청이 들어옵니다:

- "에러 메시지 포맷을 통일해주세요"
- "401 에러면 로그인 페이지로 보내주세요"
- "에러 발생 시 Sentry로 리포팅해주세요"

50군데를 돌아다니며 수정해야 합니다.

### 대안: 글로벌 에러 핸들러

**Next.js의 경우:**

```tsx
// lib/api.ts - fetch 래퍼
async function api<T>(url: string, options?: RequestInit): Promise<T> {
  const response = await fetch(url, options);

  if (!response.ok) {
    const error = await response.json();

    // 401이면 로그인으로
    if (response.status === 401) {
      redirect('/login');
    }

    // 에러 리포팅
    Sentry.captureException(error);

    // 통일된 에러 throw
    throw new ApiError(error.message, response.status);
  }

  return response.json();
}

// error.tsx - 글로벌 에러 UI
export default function Error({ error, reset }: ErrorProps) {
  return (
    <div>
      <h2>문제가 발생했습니다</h2>
      <p>{error.message}</p>
      <button onClick={reset}>다시 시도</button>
    </div>
  );
}
```

**NestJS의 경우:**

```typescript
// filters/http-exception.filter.ts
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();

    // 에러 타입에 따른 처리
    const status = exception instanceof HttpException
      ? exception.getStatus()
      : 500;

    // 로깅
    this.logger.error(exception);

    // Sentry 리포팅
    Sentry.captureException(exception);

    // 통일된 응답 포맷
    response.status(status).json({
      success: false,
      message: this.getMessage(exception),
      code: this.getErrorCode(exception),
    });
  }
}

// main.ts
app.useGlobalFilters(new GlobalExceptionFilter());
```

에러 처리 정책이 바뀌면? 한 파일만 수정하면 됩니다.

<Callout type='success' title='실용적인 원칙'>
  에러 처리는 "어디서 발생하든 어떻게 처리할지"를 한 곳에서 정의하세요. 개별 컴포넌트는 에러를 throw만 하면 됩니다.
</Callout>

## 6. 타입을 Backend/Frontend 간에 공유하라

TypeScript 풀스택 개발의 가장 큰 장점은 타입 공유입니다. 그런데 이걸 안 하는 프로젝트가 의외로 많습니다.

### 흔한 실수: 타입을 양쪽에서 따로 정의

```typescript
// Backend: user.dto.ts
export class UserDto {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

// Frontend: types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  created_at: string;  // 오타? 의도? 누가 알겠어
}
```

시간이 지나면:

- Backend에서 필드 추가 → Frontend 타입 업데이트 깜빡
- 필드명 불일치 (camelCase vs snake_case)
- 타입 불일치 (Date vs string)
- 런타임에서야 에러 발견

<Callout type='error' title='실제로 겪은 일'>
  Backend에서 응답 필드를 optional로 바꿨는데 Frontend 타입은 그대로였습니다. 프로덕션에서 "Cannot read property of undefined" 에러가 터졌습니다.
</Callout>

### 대안: tRPC를 쓰세요

진심입니다. TypeScript 풀스택이면 tRPC를 쓰지 않을 이유가 없습니다.

```typescript
// server/routers/user.ts
export const userRouter = router({
  getById: publicProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      const user = await db.user.findUnique({ where: { id: input.id } });
      return user;  // 이 타입이 자동으로 클라이언트에 전파됨
    }),

  update: publicProcedure
    .input(z.object({
      id: z.number(),
      name: z.string().min(1),
      email: z.string().email(),
    }))
    .mutation(async ({ input }) => {
      return db.user.update({ where: { id: input.id }, data: input });
    }),
});
```

```tsx
// Frontend에서 사용
function UserProfile({ userId }: { userId: number }) {
  // user 타입이 자동 추론됨. 별도 타입 정의 불필요.
  const { data: user } = trpc.user.getById.useQuery({ id: userId });

  // input 타입도 자동 검증. 잘못된 필드 넣으면 컴파일 에러.
  const updateMutation = trpc.user.update.useMutation();

  return <div>{user?.name}</div>;
}
```

**tRPC의 장점:**

1. **타입 자동 공유**: Backend 응답 타입이 Frontend에 자동 전파
2. **입력 검증**: Zod 스키마로 런타임 검증까지 해결
3. **API 문서 불필요**: 타입이 곧 문서
4. **리팩토링 안전성**: 필드명 바꾸면 양쪽에서 컴파일 에러

tRPC를 못 쓰는 환경이라면, 최소한 Zod 스키마를 공유하세요:

```typescript
// shared/schemas/user.ts
export const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
  createdAt: z.string().datetime(),
});

export type User = z.infer<typeof userSchema>;

// Backend와 Frontend 모두 이 타입을 import해서 사용
```

<Callout type='success' title='실용적인 원칙'>
  TypeScript 풀스택의 최대 장점은 End-to-End 타입 안전성입니다. 이걸 포기하면 TypeScript를 쓰는 의미가 반감됩니다. tRPC를 쓰세요.
</Callout>

## 마치며: 코드에서 나는 악취를 맡아라

이 글에서 다룬 실수들의 공통점은 **나도 모르게 SOLID 원칙을 어기게 된다**는 것입니다.

- 뷰는 단일 책임 원칙(SRP)을 위반 - 변경 지점이 분산됨
- 과도한 컴포넌트 분리는 인터페이스 분리 원칙(ISP)을 위반 - 불필요한 props 의존성 증가
- 메뉴 하드코딩은 개방-폐쇄 원칙(OCP)을 위반 - 새 요구사항마다 기존 코드 수정 필요
- 분석 없는 구현과 자의적 매핑은 KISS 원칙을 위반 - 불필요한 복잡성 추가
- 에러 핸들링 분산은 DRY 원칙을 위반 - 동일한 처리 로직이 여러 곳에 복붙됨
- 타입 분리 정의는 신뢰성을 위반 - 런타임에서야 불일치 발견

문제는 이런 위반이 코드를 작성하는 순간에는 잘 보이지 않는다는 점입니다. "이게 더 깔끔해 보이는데?"라고 생각하며 작성하지만, 시간이 지나고 유지보수할 때 비용이 드러납니다.

<Callout type='info' title='경험이 필요한 이유'>
  SOLID 원칙 위반은 코드에서 나는 악취(Code Smell)와 같습니다. 악취를 맡으려면 경험이 필요합니다. 한 번 겪어봐야 "아, 이게 그 냄새구나" 알게 됩니다.
</Callout>

이 글에서 다룬 것들도 직접 겪어보니 알게 된 것들입니다:

- 스키마 바꿨는데 뷰 수정을 깜빡해서 장애 나봐야 알게 됨
- 컴포넌트 100개 넘어가니까 간단한 수정에 30분 걸리는 걸 겪어봐야 알게 됨
- "메뉴 이름 좀 바꿔주세요"에 50개 파일 수정하면서 후회해봐야 알게 됨
- "이게 아닌데요" 듣고 절반 다시 만들어봐야 알게 됨
- "에러 메시지 포맷 통일해주세요"에 모든 페이지 돌아다녀봐야 알게 됨
- 프로덕션에서 "Cannot read property of undefined" 터져봐야 알게 됨

"필요해지면 그때 추상화하자"가 "미리 추상화해두자"보다 대부분의 경우 나은 선택이었습니다. 추상화는 복잡성을 숨기는 좋은 도구이지만, 숨겨진 복잡성은 여전히 존재합니다.

앞으로도 겪은 실수들을 이 글에 추가해나갈 예정입니다.
