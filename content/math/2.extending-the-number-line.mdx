---
title: "수직선의 구멍을 메우다"
description: "√2는 분수로 표현할 수 없다는 충격적인 발견, 점·선·면의 차원 확장, 거듭제곱과 로그의 역질문 관계까지."
date: "2025-02-18"
author: "JH"
tags: ["math", "programming", "real-numbers", "logarithm", "dimension"]
series: "Math Re:Loaded"
order: 2
---

# 수직선의 구멍을 메우다

분수(유리수)로 모든 수를 표현할 수 있을 것 같잖아. `1/3 = 0.333...`, `7/11 = 0.636363...` -- 아무리 복잡해도 분자/분모 정수 쌍이면 되니까. 그런데 고대 그리스에서 충격적인 발견이 있었어.

---

## √2: 분수로 표현 불가능한 수

한 변이 1인 정사각형의 대각선 길이는 얼마일까?

```
┌──────┐
│      │ 1
│      │
└──────┘
   1

대각선² = 1² + 1² = 2   (피타고라스)
대각선 = √2
```

√2는 분명히 존재하는 길이야 -- 자로 그릴 수 있어. 근데 이걸 `a/b`(정수의 비)로 표현하려고 하면 **불가능하다**는 게 증명돼.

### 귀류법 증명 -- 대우의 실전 사용

Article 1에서 배운 "대우"가 여기서 바로 써먹혀. 직접 증명하기 어려우니, "가정이 참이라면 모순이 발생한다 → 따라서 가정이 거짓"이라는 구조로 간다.

<Steps>
<Step title="가정">
√2 = a/b라고 하자 (a, b는 정수, 기약분수 -- 더 이상 약분 불가)
</Step>
<Step title="양변 제곱">
2 = a²/b² → a² = 2b²

a²이 2의 배수 → a도 2의 배수 (짝수의 제곱은 짝수)

a = 2k로 놓으면: (2k)² = 2b² → 4k² = 2b² → b² = 2k²
</Step>
<Step title="모순 발견">
b²도 2의 배수 → b도 2의 배수

**a도 짝수, b도 짝수** → 더 약분할 수 있다!

하지만 처음에 "기약분수"라고 가정했다. **모순.**
</Step>
<Step title="결론">
가정이 틀렸다. **√2는 분수로 표현할 수 없다.**
</Step>
</Steps>

<Callout type="note" title="반복 테마: 규칙 보존">
또 그 패턴이야. 기존 수 체계(유리수)에서 표현 못 하는 게 발견됐어. 수직선에 "구멍"이 있다는 거지. 해결책? 수를 확장해서 구멍을 메우는 거야 -- **실수**의 탄생.
</Callout>

### 유리수의 구멍, 실수의 완성

분수들(유리수)을 수직선 위에 찍으면, 빽빽하게 촘촘히 깔려 있지만 그 사이사이에 빈 점이 있어. √2, π, e 같은 것들이 그 빈 자리에 있는 거지.

```
유리수들:  ···  1.4  1.41  1.414  1.4142  ···
                      ↓
                    √2 = 1.41421356...
                    (여기에 정확히 도달하는 분수는 없음)
```

유리수(분수)와 무리수(√2, π, e 등)를 합쳐서 수직선에 빈틈이 하나도 없게 만든 게 **실수**야.

<MathCodeBridge title="유리수 vs 실수의 프로그래밍 대응" connections="유리수 (ℚ) :: 분수 타입 (정확) | 실수 (ℝ) :: float (근사)">

```math
유리수: a/b (정수 쌍)로 정확히 표현
무리수: 유한 소수로 표현 불가
실수: 빈틈 없는 연속적 수직선
```

```ts
// 유리수 = int/int로 정확히 표현 가능
type Rational = { num: number; den: number };
// 3/4, 7/11, 22/7 ...

// 실수 ≈ float (근사값)
const sqrt2: number = 1.4142135623730951;
// 실제 실수는 정밀도 한계가 없지만
// float은 유한한 비트로 근사
```

</MathCodeBridge>

---

## 점, 선, 면 -- 차원의 확장

### 점: 위치만 있고 크기는 없다

점은 수학에서 가장 근본적인 추상화야. Article 1에서 "3"이 구체적 사물에서 개수를 추출한 것처럼, 점은 구체적 사물에서 **위치만 추출**한 거야.

```
사과의 위치  ─┐
별의 위치    ─┼─→ 추상화 → "점" (위치라는 속성만 남김)
핀의 끝      ─┘
```

점에는 길이도, 넓이도, 부피도 없어. 크기가 0인 게 아니라, **크기라는 속성 자체가 없는 거**야. 인터페이스에 `size` 필드가 아예 정의되어 있지 않은 것과 비슷하지.

### 선: 독립적인 방향 하나

한 점에서 하나의 방향을 정하고, 그 방향으로 빈틈없이 점이 채워져 있는 것. 여기서 아까 배운 게 연결돼 -- 유리수만 찍으면 빽빽하지만 구멍이 있었잖아. 실수까지 메워야 빈틈이 없어졌어. **선이 진짜 "선"이 되려면, 그 위의 점들이 실수처럼 빈틈없이 연속이어야 해.**

```
점:   •                         (0차원 -- 위치만)
       ↓ 한 방향으로 연속 확장
선:   •─────────────────•       (1차원 -- 자유도 1개)
```

### 면: 독립적인 방향 하나 더

선 위의 점은 앞뒤로만 움직일 수 있어. 자유도 1개. 여기에 **기존 방향과 독립적인** 새로운 방향을 하나 더 추가하면?

```
선:   ─────────────           (자유도 1: 좌우)
       ↓ 독립적인 방향 추가
면:   ┌───────────┐
      │           │           (자유도 2: 좌우 + 상하)
      │           │
      └───────────┘
```

<Callout type="note" title="반복 테마: 직교성">
"독립적"이라는 게 핵심이야. 이미 좌우로 갈 수 있는데 또 좌우 방향을 추가하면 여전히 선이야. **기존 방향으로는 갈 수 없는** 새로운 방향이어야 차원이 늘어나. 이 "독립적인 방향"이라는 개념이 나중에 선형대수에서 **선형 독립(linear independence)**이라는 이름으로 정식 등장해.
</Callout>

### 차원 = 독립적 방향의 수

| | 점 | 선 | 면 | 공간 |
|---|---|---|---|---|
| 차원 | 0 | 1 | 2 | 3 |
| 자유도 | 없음 | 1방향 | 2방향 | 3방향 |
| 만드는 법 | 시작 | 독립 방향 +1 | 독립 방향 +1 | 독립 방향 +1 |

매번 독립적인 방향을 하나 추가해서 차원을 올리는 거야. 그리고 이 확장에는 끝이 없어 -- 수학적으로 4차원, 5차원, n차원도 같은 논리로 정의할 수 있어. 시각화는 못 하지만 구조는 동일해.

이 감각이 있으면 Article 9에서 "n차원 벡터공간"이 나왔을 때 겁먹지 않아도 돼. 그냥 독립 방향이 n개인 것뿐이니까.

---

## 거듭제곱: 곱셈의 반복

곱셈이 덧셈의 반복이었듯, 거듭제곱은 곱셈의 반복이야.

```
덧셈의 반복 → 곱셈:   3 + 3 + 3 + 3 = 3 × 4
곱셈의 반복 → 거듭제곱: 3 × 3 × 3 × 3 = 3⁴
```

여기까지는 직관적이야. 근데 문제가 생겨: **3⁰은 뭐야?** 3을 0번 곱한다?

### a⁰ = 1의 필연성

"0번 곱한다"는 말이 안 되는 것 같지만, 또 규칙 보존 원리가 등장해.

거듭제곱의 핵심 규칙: `aⁿ × aᵐ = aⁿ⁺ᵐ`

<Steps>
<Step title="규칙 확인">
`3² × 3³ = (3×3) × (3×3×3) = 3⁵` -- 지수끼리 더하면 됨
</Step>
<Step title="규칙을 0에 적용">
`3² × 3⁰ = 3²⁺⁰ = 3²` -- 이 규칙이 계속 성립하려면
</Step>
<Step title="필연적 결론">
양변에서 3²를 지우면 **`3⁰ = 1`**. 선택이 아니라 필연.
</Step>
</Steps>

같은 논리로 음수 지수도: `3² × 3⁻² = 3⁰ = 1` → **`3⁻² = 1/3² = 1/9`**

음수 지수 = 역수. 이것도 규칙 보존에서 자동으로 나와.

---

## 로그: 거듭제곱의 역질문

Article 1에서 나눗셈이 "곱셈의 역질문"이었잖아. 로그도 같은 구조야.

| 연산 | 역연산 | 질문 |
|------|--------|------|
| 덧셈 | 뺄셈 | 뭘 더했길래 이게 됐나? |
| 곱셈 | 나눗셈 | 뭘 곱했길래 이게 됐나? |
| 거듭제곱 | 로그 | **몇 번** 곱했길래 이게 됐나? |

`log₂(8) = 3`이 뜻하는 건: "2를 몇 번 곱해야 8이 되나? 3번."

<Callout type="note" title="반복 테마: 연산 ↔ 역연산">
전부 같은 패턴이야. 연산이 있으면 역연산이 있다. 거듭제곱의 역질문이 로그야.
</Callout>

### 로그의 핵심 성질 -- 왜 유용한가

로그의 가장 중요한 성질:

```
log(a × b) = log(a) + log(b)
```

**곱셈을 덧셈으로 바꿔준다.** 큰 수의 곱셈은 어렵고 덧셈은 쉽잖아. 로그 덕분에 곱셈 문제를 덧셈 문제로 변환할 수 있어.

### O(log n)의 직관

시간복잡도에서 `O(log n)`이 왜 빠른지 생각해봐. 데이터가 2배로 늘어도 연산은 1번만 추가돼. 이진탐색이 그래. 매번 반으로 쪼개니까 "몇 번 반으로 쪼개야 1개가 되나" = `log₂(n)`.

```
n = 1024일 때
log₂(1024) = 10    ← 10번만 쪼개면 됨
```

<MathCodeBridge title="이진탐색과 로그" connections="log₂(n) :: while 루프 반복 횟수 | 밑(base) = 2 :: 매번 반으로 쪼갬">

```math
log₂(n) = "n을 몇 번 반으로 쪼개야 1이 되는가"

log₂(1) = 0
log₂(2) = 1
log₂(1024) = 10
log₂(1,000,000) ≈ 20
log₂(1,000,000,000) ≈ 30
```

```ts
function binarySearch(arr, target) {
  let lo = 0, hi = arr.length - 1;
  while (lo <= hi) {          // 매번 반으로 쪼갬
    const mid = (lo + hi) >> 1;
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) lo = mid + 1;
    else hi = mid - 1;
  }
  return -1;
}
// n=10억이어도 30번이면 찾는다
```

</MathCodeBridge>

로그는 **"폭발적으로 큰 것을 다루기 쉬운 크기로 압축"**하는 도구야.

---

## Stage 1 마무리

지금까지 다룬 걸 관통하는 하나의 원리:

> **수학은 "연산을 정의하고, 규칙을 보존하면서 확장하고, 역연산을 만드는" 과정의 반복이다.**

| 확장 | 해결한 문제 | 보존한 규칙 |
|------|------------|------------|
| 자연수 → 정수 | `3 - 5 = ?` | 덧셈의 교환/결합법칙 |
| 정수 → 유리수 | `7 ÷ 3 = ?` | 분배법칙 |
| 유리수 → 실수 | √2의 존재 | 연속성 |

이 감각을 가지고 다음 Stage로 가면, **"변수"**와 **"함수"**라는 강력한 도구가 등장해. 구체적인 수가 아니라 **구조 자체**를 다루기 시작하는 거지.
