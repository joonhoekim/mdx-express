---
title: 'JavaScript 배열 필수 메서드 완벽 가이드'
description: 'map, filter, reduce, splice의 개념부터 실전 활용까지'
date: '2025-10-12'
---

# JavaScript 배열 필수 메서드 완벽 가이드

현대 JavaScript 개발에서 배열은 가장 많이 사용되는 데이터 구조 중 하나입니다. 특히 `map`, `filter`, `reduce`, `splice`와 같은 메서드들은 배열을 효과적으로 다루기 위한 필수 도구입니다. 이 글에서는 각 메서드의 기본 개념부터 실전 활용까지 자세히 알아보겠습니다.

<Callout type='info' title='학습 목표'>
  이 글을 통해 다음과 같은 내용을 배울 수 있습니다:
  - 각 메서드의 기본 개념과 사용법
  - 실제 프로젝트에서의 활용 사례
  - 메서드 간의 차이점과 선택 기준
</Callout>

## 1. map - 변환의 마법사

`map` 메서드는 배열의 각 요소를 변환하여 새로운 배열을 생성합니다. 원본 배열은 변경되지 않으며, 항상 같은 길이의 새로운 배열을 반환합니다.

### 기본 구문

```javascript
const newArray = array.map((element, index, array) => {
  // 변환 로직
  return transformedElement;
});
```

### 실전 예제

```javascript
// 기본적인 값 변환
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 객체 배열 변환
const users = [
  { id: 1, name: '김철수', age: 25 },
  { id: 2, name: '이영희', age: 30 },
  { id: 3, name: '박민수', age: 28 }
];

const userNames = users.map(user => user.name);
console.log(userNames); // ['김철수', '이영희', '박민수']

// 인덱스 활용
const indexedNames = users.map((user, index) =>
  `${index + 1}. ${user.name}`
);
console.log(indexedNames); // ['1. 김철수', '2. 이영희', '3. 박민수']
```

### 실제 활용 사례

```javascript
// API 응답 데이터 변환
const apiResponse = [
  { id: 1, first_name: 'John', last_name: 'Doe' },
  { id: 2, first_name: 'Jane', last_name: 'Smith' }
];

const formattedUsers = apiResponse.map(user => ({
  id: user.id,
  fullName: `${user.first_name} ${user.last_name}`,
  displayName: `${user.last_name}, ${user.first_name}`
}));

// React 컴포넌트 렌더링
const UserList = ({ users }) => (
  <ul>
    {users.map(user => (
      <li key={user.id}>
        {user.name} ({user.age}세)
      </li>
    ))}
  </ul>
);
```

<Callout type='note' title='💡 기억할 점'>
  `map`은 항상 새로운 배열을 반환하며, 원본 배열을 수정하지 않습니다. 각 요소에 대한 변환 로직을 적용할 때 사용하세요.
</Callout>

## 2. filter - 조건에 맞는 요소만 골라내기

`filter` 메서드는 주어진 조건 함수를 통과하는 요소만을 모아 새로운 배열을 생성합니다. 원본 배열은 변경되지 않습니다.

### 기본 구문

```javascript
const filteredArray = array.filter((element, index, array) => {
  // 조건 로직 (true를 반환하면 요소가 포함됨)
  return condition;
});
```

### 실전 예제

```javascript
// 숫자 필터링
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]

const oddNumbers = numbers.filter(num => num % 2 !== 0);
console.log(oddNumbers); // [1, 3, 5, 7, 9]

// 객체 배열 필터링
const products = [
  { id: 1, name: '노트북', price: 1000000, category: '전자제품' },
  { id: 2, name: '책상', price: 150000, category: '가구' },
  { id: 3, name: '키보드', price: 50000, category: '전자제품' },
  { id: 4, name: '의자', price: 200000, category: '가구' }
];

const electronics = products.filter(product =>
  product.category === '전자제품'
);

const affordable = products.filter(product =>
  product.price <= 200000
);

console.log(electronics); // 노트북, 키보드
console.log(affordable); // 책상, 키보드, 의자
```

### 실제 활용 사례

```javascript
// 검색 기능 구현
const searchProducts = (products, query) => {
  return products.filter(product =>
    product.name.toLowerCase().includes(query.toLowerCase())
  );
};

// 유효성 검증
const validUsers = users.filter(user =>
  user.email &&
  user.email.includes('@') &&
  user.age >= 18
);

// 중복 제거 (map과 조합)
const uniqueCategories = [...new Set(
  products.map(product => product.category)
)];
```

<Callout type='warning' title='⚠️ 주의사항'>
  `filter`는 조건 함수가 `true`를 반환하는 요소만 포함합니다. `false`, `null`, `undefined`, `0`, `NaN`, `''`는 모두 false로 간주됩니다.
</Callout>

## 3. reduce - 배열을 하나의 값으로 축소하기

`reduce` 메서드는 배열의 모든 요소를 하나의 값으로 축소합니다. 누적 계산, 그룹화, 변환 등 다양한 용도로 사용할 수 있습니다.

### 기본 구문

```javascript
const result = array.reduce((accumulator, currentValue, index, array) => {
  // 축소 로직
  return newAccumulator;
}, initialValue);
```

### 실전 예제

```javascript
// 합계 계산
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15

// 최대값 찾기
const max = numbers.reduce((acc, num) => Math.max(acc, num), -Infinity);
console.log(max); // 5

// 객체로 그룹화
const fruits = [
  { name: '사과', category: '과일' },
  { name: '바나나', category: '과일' },
  { name: '당근', category: '채소' },
  { name: '토마토', category: '채소' }
];

const groupedByCategory = fruits.reduce((acc, fruit) => {
  if (!acc[fruit.category]) {
    acc[fruit.category] = [];
  }
  acc[fruit.category].push(fruit.name);
  return acc;
}, {});

console.log(groupedByCategory);
// { 과일: ['사과', '바나나'], 채소: ['당근', '토마토'] }
```

### 실제 활용 사례

```javascript
// 장바구니 총액 계산
const cart = [
  { name: '노트북', price: 1000000, quantity: 1 },
  { name: '마우스', price: 50000, quantity: 2 },
  { name: '키보드', price: 80000, quantity: 1 }
];

const totalPrice = cart.reduce((total, item) =>
  total + (item.price * item.quantity), 0
);

// 데이터 분석
const userStats = users.reduce((stats, user) => {
  stats.totalAge += user.age;
  stats.count += 1;
  stats.averageAge = stats.totalAge / stats.count;
  return stats;
}, { totalAge: 0, count: 0, averageAge: 0 });

// 배열 평탄화
const nestedArrays = [[1, 2], [3, 4], [5, 6]];
const flatArray = nestedArrays.reduce((acc, arr) =>
  acc.concat(arr), []
);
```

<Callout type='success' title='🚀 고급 활용'>
  `reduce`는 `map`, `filter`의 기능을 모두 구현할 수 있을 만큼 강력합니다. 하지만 가독성을 위해 적절한 메서드를 선택하세요.
</Callout>

## 4. splice - 배열 직접 수정하기

`splice` 메서드는 배열의 요소를 추가, 삭제, 교체할 수 있습니다. **원본 배열을 직접 수정**한다는 점이 다른 메서드들과 다릅니다.

### 기본 구문

```javascript
// 요소 삭제
array.splice(startIndex, deleteCount);

// 요소 추가
array.splice(startIndex, 0, ...itemsToAdd);

// 요소 교체
array.splice(startIndex, deleteCount, ...itemsToAdd);
```

### 실전 예제

```javascript
let fruits = ['사과', '바나나', '오렌지', '포도', '키위'];

// 요소 삭제
const removed = fruits.splice(2, 1); // 인덱스 2부터 1개 삭제
console.log(fruits); // ['사과', '바나나', '포도', '키위']
console.log(removed); // ['오렌지']

// 요소 추가
fruits.splice(2, 0, '체리', '블루베리'); // 인덱스 2에 추가
console.log(fruits); // ['사과', '바나나', '체리', '블루베리', '포도', '키위']

// 요소 교체
fruits.splice(1, 2, '망고', '파인애플'); // 인덱스 1부터 2개를 교체
console.log(fruits); // ['사과', '망고', '파인애플', '블루베리', '포도', '키위']
```

### 실제 활용 사례

```javascript
// 할 일 목록 관리
class TodoList {
  constructor() {
    this.todos = [];
  }

  addTodo(todo, index = this.todos.length) {
    this.todos.splice(index, 0, todo);
  }

  removeTodo(index) {
    return this.todos.splice(index, 1)[0];
  }

  updateTodo(index, newTodo) {
    this.todos.splice(index, 1, newTodo);
  }
}

// 큐 구현
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(item) {
    this.items.splice(this.items.length, 0, item);
  }

  dequeue() {
    return this.items.splice(0, 1)[0];
  }
}
```

<Callout type='error' title='❌ 위험성'>
  `splice`는 원본 배열을 직접 수정하므로, 불변성을 유지해야 하는 경우 주의해서 사용하세요. 가능하다면 `slice`, `concat` 등을 고려해보세요.
</Callout>

## 메서드 비교 및 선택 가이드

<Tabs defaultValue='comparison'>
  <TabsList>
    <TabsTrigger value='comparison'>특성 비교</TabsTrigger>
    <TabsTrigger value='usage'>사용 사례</TabsTrigger>
    <TabsTrigger value='performance'>성능 고려사항</TabsTrigger>
  </TabsList>

  <TabsContent value='comparison'>
    | 메서드 | 반환값 | 원본 수정 | 용도 |
    |--------|--------|-----------|------|
    | `map` | 새로운 배열 | ❌ | 요소 변환 |
    | `filter` | 새로운 배열 | ❌ | 요소 필터링 |
    | `reduce` | 단일 값 | ❌ | 축소/집계 |
    | `splice` | 삭제된 요소 배열 | ✅ | 직접 수정 |

  </TabsContent>

  <TabsContent value='usage'>
    ### 언제 어떤 메서드를 사용할까?

    - **map**: 모든 요소를 변환할 때
    - **filter**: 특정 조건을 만족하는 요소만 선택할 때
    - **reduce**: 배열을 단일 값으로 집계할 때
    - **splice**: 배열을 직접 수정해야 할 때 (주의해서 사용)

    ```javascript
    // 같은 결과를 내는 다른 방법들
    const numbers = [1, 2, 3, 4, 5];

    // map + filter 조합
    const result1 = numbers
      .filter(num => num % 2 === 0)
      .map(num => num * 2);

    // reduce로 동일한 결과
    const result2 = numbers.reduce((acc, num) => {
      if (num % 2 === 0) {
        acc.push(num * 2);
      }
      return acc;
    }, []);
    ```
  </TabsContent>

  <TabsContent value='performance'>
    ### 성능 고려사항

    - **대용량 배열**: `splice`는 직접 수정이므로 가장 빠름
    - **불변성 필요**: `map`, `filter`, `reduce` 사용
    - **메모리 사용**: 새로운 배열 생성 메서드들은 추가 메모리 소요
    - **체이닝**: 메서드 체이닝 시 중간 배열 생성에 주의

    ```javascript
    // 비효율적인 체이닝 (중간 배열 3개 생성)
    const result = array
      .map(item => item.value)
      .filter(value => value > 10)
      .reduce((sum, value) => sum + value, 0);

    // 최적화된 reduce 사용 (중간 배열 없음)
    const optimized = array.reduce((sum, item) => {
      if (item.value > 10) {
        return sum + item.value;
      }
      return sum;
    }, 0);
    ```
  </TabsContent>
</Tabs>

## 실전 팁과 모범 사례

<Steps>
  <Step title="불변성 유지하기">
    가능하다면 `splice` 대신 `map`, `filter`, `reduce`를 사용하세요. React와 같은 라이브러리에서는 불변성이 중요합니다.

    ```javascript
    // ❌ 좋지 않은 예
    const addItem = (array, item) => {
      array.push(item); // 원본 수정
      return array;
    };

    // ✅ 좋은 예
    const addItem = (array, item) => [...array, item]; // 불변성 유지
    ```
  </Step>

  <Step title="타입 안전성 확보">
    TypeScript를 사용할 때는 제네릭을 활용하여 타입 안정성을 높이세요.

    ```typescript
    interface User {
      id: number;
      name: string;
      age: number;
    }

    const users: User[] = [/* ... */];

    // 타입 추론이 제대로 작동함
    const names = users.map(user => user.name); // string[]
    const adults = users.filter(user => user.age >= 18); // User[]
    ```
  </Step>

  <Step title="에러 처리">
    배열 메서드 사용 시 예외 상황을 고려하세요.

    ```javascript
    // 안전한 reduce 사용
    const safeSum = (numbers: number[]) => {
      return numbers?.reduce((sum, num) => sum + num, 0) ?? 0;
    };

    // 빈 배열 처리
    const getFirstEven = (numbers: number[]) => {
      return numbers.find(num => num % 2 === 0) ?? null;
    };
    ```
  </Step>

  <Step title="메서드 체이닝">
    적절한 체이닝으로 코드 가독성을 높이세요.

    ```javascript
    const result = users
      .filter(user => user.isActive)
      .map(user => ({
        id: user.id,
        displayName: `${user.firstName} ${user.lastName}`
      }))
      .sort((a, b) => a.displayName.localeCompare(b.displayName));
    ```
  </Step>
</Steps>

## 결론

JavaScript의 `map`, `filter`, `reduce`, `splice`는 배열을 효과적으로 다루기 위한 핵심 메서드들입니다. 각 메서드의 특징을 이해하고 적절한 상황에 맞게 사용한다면 더 깔끔하고 효율적인 코드를 작성할 수 있습니다.

<Blockquote author='JavaScript 명언'>
  "배열 메서드를 마스터하면 코드가 노래하듯 흘러간다."
</Blockquote>

<Callout type='success' title='다음 단계'>
  이 메서드들을 익혔다면 이제 `find`, `some`, `every`, `flatMap` 등의 다른 배열 메서드들도 공부해보세요. 또한 함수형 프로그래밍 개념과 결합하면 더욱 강력한 코드를 작성할 수 있습니다.
</Callout>

<ReferenceList title='참고 자료'>
  <Reference
    title='MDN Web Docs - Array'
    description='JavaScript 배열 메서드의 공식 문서'
    href='https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array'
    type='documentation'
  />
  <Reference
    title='JavaScript.info - Array methods'
    description='배열 메서드에 대한 상세한 설명과 예제'
    href='https://ko.javascript.info/array-methods'
    type='tutorial'
  />
  <Reference
    title='Functional Programming in JavaScript'
    description='함수형 프로그래밍 관점에서의 배열 메서드 활용'
    href='https://github.com/MostlyAdequate/mostly-adequate-guide'
    type='book'
  />
</ReferenceList>
